import struct
import numpy as np
from ReadDose import ReadCSDose
from GaussianErrorFit import GaussianERFFit

class CalcSigmaX_Y():
    
    def __init__(self,ref_dose_path,new_dose_path):
        self.ref_dose_path = ref_dose_path
        self.new_dose_path = new_dose_path
       
        
    def cal_sigma_for_allLayers(self,direction,grid,brag_peak_CS,BeamDirection):
        path_benchMark =  self.ref_dose_path
        path_proton = self.new_dose_path
        data_2DbenchMark = ReadCSDose(path_benchMark)        
        lay_cnt = data_2DbenchMark.Get_layCnt(BeamDirection)
        benchMarch_sigma = []  # [sigmaX,sigmaY]
        protonCS_sigma = []
        del_sigma = []
        for lay_idx in range(0, lay_cnt, 1):  # loop for all the layers                
            data_2DbenchMark = ReadCSDose(path_benchMark, direction, lay_idx)
            data_2Dproton = ReadCSDose(path_proton, direction, lay_idx)
                    
            axx_benchMarch = GaussianERFFit(data_2DbenchMark._data2D, grid)
            axx_proton = GaussianERFFit(data_2Dproton._data2D, grid)
                     
            try:                    
                if hasattr(axx_benchMarch, 'sigmaX'):
                    benchMarch_sigma.append([axx_benchMarch.sigmaX, axx_benchMarch.sigmaY])
                else:
                    benchMarch_sigma.append([0, 0]) # zero dose case: assign to sigmaX and sigmaY to 0 currently
            except:
                pass
                    
            try:
                if hasattr(axx_proton, 'sigmaX'):
                    protonCS_sigma.append([axx_proton.sigmaX, axx_proton.sigmaY])
                else:
                    protonCS_sigma.append([0, 0]) # zero dose case: assign to sigmaX and sigmaY to 0 currently
            except:
                pass                
            del_sigma.append([axx_benchMarch.sigmaX - axx_proton.sigmaX, axx_benchMarch.sigmaY - axx_proton.sigmaY])    
        return  benchMarch_sigma, protonCS_sigma, del_sigma